<------------------Brutreforce-------------------->
public static void rearrange(int[] arr, int n) {
    int[] temp = new int[n];
    int index = 0;

    // First copy negative numbers
    for (int i = 0; i < n; i++) {
        if (arr[i] < 0) {
            temp[index++] = arr[i];
        }
    }

    // Then copy non-negative numbers
    for (int i = 0; i < n; i++) {
        if (arr[i] >= 0) {
            temp[index++] = arr[i];
        }
    }

    // Copy back to original array
    for (int i = 0; i < n; i++) {
        arr[i] = temp[i];
    }
}
    TC=O(n) ,Sc=O(n)


<-----------------Optimal----------------->

class Solution {

    public void Rearrange(int a[], int n) {

        for (int i = 0; i < n; i++) {

            // process only negative elements
            if (a[i] < 0) {

                int temp = a[i];
                int j = i - 1;

                // shift non-negative elements to right
                while (j >= 0 && a[j] >= 0) {
                    a[j + 1] = a[j];
                    j--;
                }

                // place negative element at correct position
                a[j + 1] = temp;
            }
        }
    }
}
      Tc= O(NÂ²) , Sc=O(1)
